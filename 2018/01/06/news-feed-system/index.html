<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 101 Understand News Feed System and Design a Mini-Twitter · Liang Yu's Website</title><meta name="description" content="101 Understand News Feed System and Design a Mini-Twitter - Liang Yu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.yuliang.xyz/atom.xml" title="Liang Yu's Website"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">101 Understand News Feed System and Design a Mini-Twitter</h1><div class="post-info">Jan 6, 2018</div><div class="post-content"><p><a href="https://en.wikipedia.org/wiki/Fan-out_(software" target="_blank" rel="noopener">Fan-out (software) Wiki</a>)<br><a href="https://www.quora.com/What-is-fan-out-write-and-fan-out-read-in-scalability" target="_blank" rel="noopener">What is fan out write and fan out read in scalability?</a></p>
<p>需要好好研究一下的<br><a href="https://toutiao.io/posts/125383/app_preview" target="_blank" rel="noopener">几个大型网站的 Feeds (Timeline) 设计简单对比</a></p>
<h1 id="Understand-News-Feed-System-and-Design-a-Mini-Twitter"><a href="#Understand-News-Feed-System-and-Design-a-Mini-Twitter" class="headerlink" title="Understand News Feed System and Design a Mini-Twitter"></a>Understand News Feed System and Design a Mini-Twitter</h1><p>Leverage the 4S analysis method </p>
<h2 id="Scenario-–-what-features-I-should-design"><a href="#Scenario-–-what-features-I-should-design" class="headerlink" title="Scenario – what features I should design"></a>Scenario – what features I should design</h2><h3 id="Ask-the-Interviewer"><a href="#Ask-the-Interviewer" class="headerlink" title="Ask the Interviewer"></a>Ask the Interviewer</h3><ol>
<li>需要设计哪些功能</li>
<li>需要承受多大的访问量？<ul>
<li>日活跃用户 Daily Active users (DAU)</li>
<li>Twitter: MAU 313M, DAU ~ 150M+</li>
<li>Read more: <a href="https://wechatinchina.com/thread-28820-1-1.html" target="_blank" rel="noopener">比MAU和DAU更重要的是了解 用戶習慣</a></li>
</ul>
</li>
</ol>
<h3 id="List-functions-of-twitter-one-by-one"><a href="#List-functions-of-twitter-one-by-one" class="headerlink" title="List functions of twitter one by one"></a>List functions of twitter one by one</h3><p>brain storm</p>
<ul>
<li>Register/Login</li>
<li>User Profile Display/Edit</li>
<li>Upload Image/Video *</li>
<li>Search *</li>
<li>Post/Share a tweet</li>
<li>Timeline/News Feed</li>
<li>Follow/Unfollow a user</li>
</ul>
<h3 id="Pick-up-the-Core-Functions-for-version-1-0"><a href="#Pick-up-the-Core-Functions-for-version-1-0" class="headerlink" title="Pick up the Core Functions for version 1.0"></a>Pick up the Core Functions for version 1.0</h3><ul>
<li>Post a Tweet</li>
<li>Timeline</li>
<li>News Feed</li>
<li>Follow/Unfollow a user</li>
<li>Register/Login</li>
</ul>
<p><strong>S</strong>cenario – Analysis &amp; Predict</p>
<ul>
<li>Concurrent User<ul>
<li>日活跃 <em> 平均每个用户请求次数 / 一天多少秒 = 150M </em> 60 / 86400 ~= 100K</li>
<li>峰值 Peak = Average Concurrent User * 3 ～= 300K</li>
<li>快速增长的产品 Fast Growing<ul>
<li>MAX peak users in 3 months = Peak User * 2 </li>
</ul>
</li>
</ul>
</li>
<li>Read QPS (Query Per Second)<ul>
<li>300K</li>
</ul>
</li>
<li>Write QPS<ul>
<li>5K</li>
</ul>
</li>
</ul>
<h4 id="What-does-QPS-do-–-pick-up-the-right-hardware"><a href="#What-does-QPS-do-–-pick-up-the-right-hardware" class="headerlink" title="What does QPS do – pick up the right hardware"></a>What does QPS do – pick up the right hardware</h4><ol>
<li>QPS = 100 –&gt; You can use your Laptop as Web server</li>
<li>QPS = 1K</li>
<li>QPS = 1M</li>
</ol>
<h6 id="The-relationship-between-QPS-Web-Server-Database"><a href="#The-relationship-between-QPS-Web-Server-Database" class="headerlink" title="The relationship between QPS/ Web Server/ Database"></a>The relationship between QPS/ Web Server/ Database</h6><ul>
<li>一台 Web Server 约承受访问量是1K的QPS（逻辑处理时间和数据库查询的瓶颈）</li>
<li>一台 SQL Database 约承受访问量是1K的QPS（JOIN和INDEX Query比较多的话，这个值会更小）</li>
<li>一台 NoSQL Database (Cassandra) 约承受访问量是10K的QPS</li>
<li>一台 NoSQL Database（Memcached）约承受访问量是1M的QPS</li>
</ul>
<p><strong>S</strong>ervice – 将大系统拆分成小系统</p>
<p>– 重放需求<br>– 归并需求</p>
<ol>
<li>User Service [Register/Login]</li>
<li>Tweet Service [Post tweet/News Feed/ Timeline]</li>
<li>Media Service [Upload Image/Video]</li>
<li>Friendship Service [Follow/Unfollow]</li>
</ol>
<p><strong>S</strong>torage – 数据如何存储与访问</p>
<ol>
<li>Select 为每个Service选择存储结构</li>
<li>Schema 细化表结构</li>
</ol>
<h4 id="有哪几种存储数据的选择"><a href="#有哪几种存储数据的选择" class="headerlink" title="有哪几种存储数据的选择"></a>有哪几种存储数据的选择</h4><ol>
<li>Database<ul>
<li>Relationship SQL Database<ul>
<li>User Table</li>
</ul>
</li>
<li>NoSQL Database<ul>
<li>Tweets</li>
<li>Social Graph e.g. Followers</li>
</ul>
</li>
</ul>
</li>
<li><p>File System (Understand what is File System!)</p>
<ul>
<li>Pictures, Videos (Media Files, There should be a Media Server)</li>
<li>Think about other things</li>
</ul>
</li>
<li><p>Cache System</p>
<ul>
<li>anything that not supports Non-persistent</li>
</ul>
</li>
</ol>

<h4 id="选择的步骤"><a href="#选择的步骤" class="headerlink" title="选择的步骤"></a>选择的步骤</h4><ol>
<li>Select appropricate storage service for each Application/Service<ul>
<li>User Service  : SQL,         like MySQL</li>
<li>Tweet Service : NoSQL,       like mongoDB</li>
<li>Media Service : File System, like Amazon S3</li>
<li>Friendship Service : SQL/NoSQL</li>
</ul>
</li>
</ol>
<ol>
<li>Finish the Schema with details</li>
</ol>
<p>Diagram</p>
<p>程序 = 算法 + 数据结构<br>系统 = 服务 + 数据存储</p>
<h4 id="Question-设计Schema"><a href="#Question-设计Schema" class="headerlink" title="Question: 设计Schema"></a><strong>Question:</strong> 设计Schema</h4><ul>
<li>User Service  : SQL</li>
</ul>
<p>User Table</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id</td>
<td style="text-align:center">integer</td>
</tr>
<tr>
<td style="text-align:center">username</td>
<td style="text-align:center">varchar</td>
</tr>
<tr>
<td style="text-align:center">email</td>
<td style="text-align:center">varchar</td>
</tr>
<tr>
<td style="text-align:center">password</td>
<td style="text-align:center">varchar</td>
</tr>
</tbody>
</table>
<ul>
<li>Tweet Service : NoSQL</li>
</ul>
<p>Tweet Table</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id</td>
<td style="text-align:center">integer</td>
</tr>
<tr>
<td style="text-align:center">user_id</td>
<td style="text-align:center">foreignKey</td>
</tr>
<tr>
<td style="text-align:center">content</td>
<td style="text-align:center">varchar</td>
</tr>
<tr>
<td style="text-align:center">createdAt</td>
<td style="text-align:center">varchar</td>
</tr>
</tbody>
</table>
<ul>
<li>Friendship Service </li>
</ul>
<p>Friendship Table</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">from_user_id</td>
<td style="text-align:center">foreignKey</td>
</tr>
<tr>
<td style="text-align:center">to_user_id</td>
<td style="text-align:center">foreignKey</td>
</tr>
</tbody>
</table>
<h3 id="Question-News-Feed-如何存取"><a href="#Question-News-Feed-如何存取" class="headerlink" title="Question: News Feed 如何存取"></a><strong>Question:</strong> News Feed 如何存取</h3><h5 id="What-is-the-News-Feed-新鲜事系统"><a href="#What-is-the-News-Feed-新鲜事系统" class="headerlink" title="What is the News Feed? 新鲜事系统"></a>What is the News Feed? 新鲜事系统</h5><ul>
<li>The Feed you read after you open/login Facebook/Twitter/朋友圈</li>
<li>The info set posted by all your friends</li>
</ul>
<h5 id="Common-News-Feed-Examples"><a href="#Common-News-Feed-Examples" class="headerlink" title="Common News Feed Examples"></a>Common News Feed Examples</h5><ul>
<li>Facebook</li>
<li>Twitter</li>
<li>朋友圈</li>
<li>RSS Reader</li>
</ul>
<p>######Core Properties of News Feed System #####</p>
<ul>
<li>follow/ being followed</li>
<li>The news are unique for different people</li>
</ul>
<h5 id="Storage-Pull-Model"><a href="#Storage-Pull-Model" class="headerlink" title="Storage - Pull Model"></a>Storage - Pull Model</h5><ul>
<li><p>Alogorithm</p>
<ul>
<li>在用户查看News Feed时候， 获取每个好友的前100条Tweets，合并出前100条 News Feed<pre><code>+ K路归并算法 &amp; 外部存储排序 （Merge K Sorted Arrays）
</code></pre></li>
</ul>
</li>
<li><p>Complexity Analysis</p>
<ul>
<li>News Feed<ul>
<li>假如有N个关注对象，则为N次DB Readers的时间 + K路归并时间 （忽略）</li>
<li>为什么K路归并的时间可以忽略</li>
</ul>
</li>
<li>Post a tweet<ul>
<li>一次DB Write的时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Pull-Model-At-a-Nutshell"><a href="#Pull-Model-At-a-Nutshell" class="headerlink" title="Pull Model At a Nutshell"></a>Pull Model At a Nutshell</h5><img src="/2018/01/06/news-feed-system/pull_model_principle.png" title="[]">
<h5 id="Question-What-is-the-problem-with-Pull-Model"><a href="#Question-What-is-the-problem-with-Pull-Model" class="headerlink" title="Question: What is the problem with Pull Model"></a><strong>Question:</strong> What is the problem with Pull Model</h5><h1 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a><strong>S</strong>cale</h1><h2 id="Two-Areas-to-Think-About"><a href="#Two-Areas-to-Think-About" class="headerlink" title="Two Areas to Think About"></a>Two Areas to Think About</h2><ul>
<li>Optimize</li>
<li>Maintenance</li>
</ul>
<h2 id="Step-1-How-to-Optimize"><a href="#Step-1-How-to-Optimize" class="headerlink" title="Step 1: How to Optimize"></a>Step 1: How to Optimize</h2><ol>
<li>Solve design defects in previous solution<ul>
<li>Pull vs Push</li>
<li>Normalize vs De-normalize</li>
</ul>
</li>
<li>More features if have time<ul>
<li>Edit</li>
<li>Delete</li>
<li>Media</li>
<li>Ads</li>
</ul>
</li>
<li>Special Cases<ul>
<li>Some celebrities, like Lady Gaga</li>
<li>Some hibernating users, (Inactive Users)</li>
</ul>
</li>
</ol>
<h2 id="Step-2-Maintenance"><a href="#Step-2-Maintenance" class="headerlink" title="Step 2: Maintenance"></a>Step 2: Maintenance</h2><ol>
<li>Robust<ul>
<li>If one sever/databse down</li>
</ul>
</li>
<li>Scalability<ul>
<li>If requests skyrocket, how to scale</li>
</ul>
</li>
</ol>
<h6 id="QPS-Comparison-between-MySQL-and-Memcached"><a href="#QPS-Comparison-between-MySQL-and-Memcached" class="headerlink" title="QPS Comparison between MySQL and Memcached"></a>QPS Comparison between MySQL and Memcached</h6><p>差了大约100倍的样子</p>
<h3 id="Example-of-top-companies"><a href="#Example-of-top-companies" class="headerlink" title="Example of top companies"></a>Example of top companies</h3><ol>
<li>Facebook NewsFeed<br>典型的Pull方式，读时fanout，获得所有好友的活动，再进行聚合，rank，排序等操作（这几步后续动作，是feed和timeline的最大不同特点）。Facebook把这种模式叫做“Multifeed – Multi-fetch and aggregate stories at read time”。 </li>
</ol>
<hr>
<h2 id="Frontend-Tier-lt-——-gt-Aggregator-lt-——-gt-multiple-Leaf-nodes"><a href="#Frontend-Tier-lt-——-gt-Aggregator-lt-——-gt-multiple-Leaf-nodes" class="headerlink" title="Frontend Tier  &lt;——&gt;  Aggregator &lt;——-&gt; multiple Leaf nodes"></a>Frontend Tier  &lt;——&gt;  Aggregator &lt;——-&gt; multiple Leaf nodes</h2><p>FB的众多产品、模块，通讯协议自然用自家的Thrift，还用到SMC和其他的底层平台。 </p>
<p>存储模块，有自家的“排序”存储文件（feed要按时间倒排，还有rank影响排序…内存的B树排序结构，可以预测性的合并到文件。可能开源）。还大量使用了 Redis 和Google开发的开源持久化KV存储： LevelDB 。 </p>
<p>Feeds相对于Timeline，最大特点是有rank影响排序，需要按类型合并，有推荐算法的插入，有更复杂的数据结构…这些都是影响架构设计的重要因素，但这些都没有文档详细描述。拉模式下，最重要的是高效稳定、分布式的Aggregator的设计，也没有详细文档说明。<br>(Facebook可以说是技术文档最不透明的网站了，特别是相较于他拥有最大的UGC而言。)</p>
<ol>
<li>Twitter Timeline<br>Push 方式. 和FB的Feed最大的区别，就是要解决fan-out的效率和全文搜索的效率。</li>
</ol>
<p>主要特点是对fanout的处理：队列化(有自己用Scala语言实现的Kestrel队列)，并发处理推送等大消耗业务，各级缓存(包括In-Proc)…     </p>
<p>通讯协议上， Kestrel 复用了MemCached协议；而Timeline API模块使用了FB的Thrift。通信框架是大量使用的自己开发的（已开源）RPC框架 Finagle （A fault tolerant, protocol-agnostic RPC system）。 </p>
<p>搜索引擎使用了Lucene。存储也大量使用了Redis</p>
<ol>
<li>RenRen.com<br>从查询的效率考虑, 人人网采用了推模式(近似twitter模式)。但是，人人网的Feeds，又比twitter类的timeline，有更复杂的结构和功能需求，所以在设计上，会有FB和Twitter双方融合的特点。</li>
</ol>
<p>在Cache上，人人有自己实现的Server来支持。特别是在IndexCache上，基本数据结构和FB一样，使用了C++ Boost multi-index container；序列化和压缩采用Protobuf和QuickLZ。特别是有专门实现的解决feed索引持久化难题的Feed Index DB。 </p>
<p>最后用模板渲染引擎(也是C++实现)来显示复杂的Feed。 </p>
<p>Renren在网络通信上大量使用 ICE框架 ，协议上多用Protobuf，实现缓存等中间层、新鲜事儿等系统。大量自己开发的server集群，通过他们高效通信。 </p>
<p>在高性能计算上，Renren网倾向用C/C++编写定制性Server，保证数据中心存储，大规模数据尽量在进程内访问。像IndexCache Server（海量的Feed数据装载在单一Server内，实现“数据尽可能靠近CPU”的原则），实现高速排序等计算需求；此外还有文档里提及的渲染Server…都是用C写的专用Server。好处自然是本地内存的纳秒级访问速度，远远高于网络IO，可实现极高的性能。 </p>
<p>现在，人人网的架构也在向Service化方向发展，并封装成了XOA，基础总线使用了Thrift，消息队列用了 ZeroMQ …</p>
<p>《人人网Feed系统结构浅析.pdf》<br>《人人网网站架构–服务化的演进》</p>
<ol>
<li>Sina Weibo</li>
</ol>
<p>TimYang的《 构建可扩展的微博架构 》<br>《新浪微博cache设计谈.pdf》 </p>
<ol>
<li>Tencent Weibo</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2018/01/20/google-distributed-file-system/" class="prev">PREV</a><a href="/2018/01/05/system-design-101/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://www.yuliang.xyz">Liang Yu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>