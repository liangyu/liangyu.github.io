<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java in Ten Years · Liang Yu's Website</title><meta name="description" content="Java in Ten Years - Liang Yu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.yuliang.xyz/atom.xml" title="Liang Yu's Website"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java in Ten Years</h1><div class="post-info">Mar 9, 2018</div><div class="post-content"><h2 id="Java-Fundamental"><a href="#Java-Fundamental" class="headerlink" title="Java Fundamental"></a>Java Fundamental</h2><ol>
<li>HashMap的源码，实现原理，JDK8中对HashMap做了怎样的优化。</li>
<li>HaspMap扩容是怎样扩容的，为什么都是2的N次幂的大小。</li>
<li>HashMap，HashTable，ConcurrentHashMap的区别。</li>
</ol>
<p>HashMap, HashTable都实现了Map接口，HashMap是HashTable的轻量级实现，非线程安全。<br>HashMap允许 null key 作为key或者value，效率高于HashTable，因为不是线程安全的<br>HashMap在多线程情况下，需要提供而外的同步。</p>
<p>Hashtable有contains方法，hashmap有containsValue和containsKey。</p>
<p>HashTable继承自Dictionary类，HashMap是Java1.2 中Map interface的一个实现</p>
<ol>
<li>极高并发下HashTable和ConcurrentHashMap哪个性能更好，为什么，如何实现的。</li>
<li>HashMap在高并发下如果没有处理线程安全会有怎样的安全隐患，具体表现是什么。</li>
<li>java中四种修饰符的限制范围。</li>
<li>Object类中的方法。</li>
<li>接口和抽象类的区别，注意JDK8的接口可以有实现。</li>
</ol>
<p>Override 重写 是父类和子类之间多态性的一种表现，子类中定义的方法与其父类有相同的名称和参数，则是重写<br>Overloade 重载 是一个类中多态性的一种表现， 一个类中定义多个同名的方法，它们有不同的参数个数或者不同的参数类型，则是重载</p>
<ol>
<li>动态代理的两种方式，以及区别。</li>
<li>Java序列化的方式。</li>
<li>传值和传引用的区别，Java是怎么样的，有没有传值引用。</li>
<li>一个ArrayList在循环过程中删除，会不会出问题，为什么。</li>
<li>@transactional注解在什么情况下会失效，为什么。</li>
<li>你所知道的集合类都有哪些，主要方法</li>
</ol>
<p>List 和 Map，List的实现有ArrayList和 Vector。 它们是可变大小的列表，适合构建，存储和操作任何类型对象的元素列表。<br>List适用于按数值索引访问元素的情况。Map提供了一个更通用的元素存储方法，Map集合类用于存储元素对（键和值），其中每个键<br>映射到一个值。</p>
<ol>
<li>ArrayList, Vector, LinkedList 的储存性能和特性<br>ArrayList 和 Vector都是用数组方式储存数据，此数组的元素大于实际存储的数据，以便增加和插入元素。<br>都允许直接按序号索引元素，但是插入元素需要涉及元素移动等内存操作，所以索引数据快，而插入数据慢</li>
</ol>
<p>vector使用了synchronized方法而线程安全，性能通常比Arraylist差，而LinkedList 使用双向链表实现存储，按序号<br>索引数据需要进行前向或后向便利，但是插入数据时候，只需要记录本项都前后项即可，所以插入快。    </p>
<ol>
<li><p>Collection 和 Collections等区别<br>Collection是集合类的上级接口，继承它的接口有Set和List<br>Collections是针对集合类的一个帮助类，他提供一系列的静态方法实现对各种集合对搜索，排序，线程安全化的操作。</p>
</li>
<li><p>final, finally, finalize 的区别<br>final用于声明属性，方法和类，分别表示属性不可变， 方法不可覆盖，类不可继承<br>finally是异常处理的一个部分，在catch后，总是执行的那些操作需要放在finally的这个block块中，<br>finalize是Ojbect类的一个方法，在垃圾收集器执行时时候，会调用被回收对象的此方法，可以覆盖此方法<br>提供垃圾收集时候的其他资源回收，例如关闭文件。</p>
</li>
</ol>
<h2 id="Data-Structure-and-Algorithm"><a href="#Data-Structure-and-Algorithm" class="headerlink" title="Data Structure and Algorithm"></a>Data Structure and Algorithm</h2><ol>
<li>B+树</li>
<li>快速排序，堆排序，插入排序（其实八大排序算法都应该了解</li>
<li>一致性Hash算法，一致性Hash算法的应用</li>
</ol>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ol>
<li>JVM的内存结构。</li>
<li>JVM方法栈的工作过程，方法栈和本地方法栈有什么区别。</li>
<li>JVM的栈中引用如何和堆中的对象产生关联。</li>
<li>可以了解一下逃逸分析技术。</li>
<li>GC的常见算法，CMS以及G1的垃圾回收过程，CMS的各个阶段哪两个是Stop the world的，CMS会不会产生碎片，G1的优势。</li>
<li>标记清除和标记整理算法的理解以及优缺点。</li>
<li>eden survivor区的比例，为什么是这个比例，eden survivor的工作过程。</li>
<li>JVM如何判断一个对象是否该被GC，可以视为root的都有哪几种类型。</li>
<li>强软弱虚引用的区别以及GC对他们执行怎样的操作。</li>
<li>Java是否可以GC直接内存。</li>
<li>Java类加载的过程。</li>
<li>双亲委派模型的过程以及优势。</li>
<li>常用的JVM调优参数。</li>
<li>dump文件的分析。</li>
<li>Java有没有主动触发GC的方式（没有)</li>
</ol>
<h2 id="Multi-threading"><a href="#Multi-threading" class="headerlink" title="Multi-threading"></a>Multi-threading</h2><ol>
<li>Java实现多线程有哪几种方式。</li>
<li>Callable和Future的了解。</li>
<li>线程池的参数有哪些，在线程池创建一个线程的过程。</li>
<li>volitile关键字的作用，原理。</li>
<li>synchronized关键字的用法，优缺点。</li>
<li>Lock接口有哪些实现类，使用场景是什么。</li>
</ol>
<p>Lock能完成synchronzied所实现的所有功能。<br>Lock比synchronized更精细的线程语义和更好的性能。<br>Synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally block中释放</p>
<ol>
<li>可重入锁的用处及实现原理，写时复制的过程，读写锁，分段锁（ConcurrentHashMap中的segment）。</li>
<li>悲观锁，乐观锁，优缺点，CAS有什么缺陷，该如何解决。</li>
<li>ABC三个线程如何保证顺序执行。</li>
<li>线程的状态都有哪些。</li>
<li>sleep和wait的区别。</li>
<li>notify和notifyall的区别。</li>
<li>ThreadLocal的了解，实现原理。</li>
</ol>
<h2 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h2><ol>
<li>常见的数据库优化手段</li>
<li>索引的优缺点，什么字段上建立索引</li>
<li>数据库连接池。</li>
<li>durid的常用配置。</li>
</ol>
<h2 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h2><ol>
<li>TCP，UDP区别。</li>
<li>三次握手，四次挥手，为什么要四次挥手。</li>
<li>长连接和短连接。</li>
<li>连接池适合长连接还是短连接。</li>
</ol>
<h2 id="Design-Pattern"><a href="#Design-Pattern" class="headerlink" title="Design Pattern"></a>Design Pattern</h2><ol>
<li>观察者模式</li>
<li>代理模式</li>
<li>单例模式，有五种写法，可以参考文章<a href="https://segmentfault.com/a/1190000010755849" target="_blank" rel="noopener">Java中单例模式的五种实现方式</a></li>
<li>可以考Spring中使用了哪些设计模式</li>
</ol>
<h2 id="Distrubuted-System"><a href="#Distrubuted-System" class="headerlink" title="Distrubuted System"></a>Distrubuted System</h2><ol>
<li>分布式事务的控制。</li>
<li>分布式锁如何设计。</li>
<li>分布式session如何设计。</li>
<li>dubbo的组件有哪些，各有什么作用。</li>
<li>zookeeper的负载均衡算法有哪些。</li>
<li>dubbo是如何利用接口就可以通信的。</li>
</ol>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><ol>
<li>redis和memcached的区别。</li>
<li>redis支持哪些数据结构。</li>
<li>redis是单线程的么，所有的工作都是单线程么。</li>
<li>redis如何存储一个String的。</li>
<li>redis的部署方式，主从，集群。</li>
<li>redis的哨兵模式，一个key值如何在redis集群中找到存储在哪里。</li>
<li>redis持久化策略。</li>
</ol>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><ol>
<li>SpringMVC的Controller是如何将参数和前端传来的数据一一对应的。</li>
<li>Mybatis如何找到指定的Mapper的，如何完成查询的。</li>
<li>Quartz是如何完成定时任务的。</li>
<li>自定义注解的实现。</li>
<li>Spring使用了哪些设计模式。</li>
<li>Spring的IOC有什么优势。</li>
<li>Spring如何维护它拥有的bean。</li>
</ol>
<h2 id="Something-Novice"><a href="#Something-Novice" class="headerlink" title="Something Novice"></a>Something Novice</h2><ol>
<li>JDK8的新特性，流的概念及优势，为什么有这种优势。</li>
<li>区块链了解</li>
<li>如何设计双11交易总额面板，要做到高并发高可用。</li>
</ol>
<h2 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h2><ol>
<li>可以去leetcode上刷题换换思路。</li>
<li>八大排序算法一定要手敲一遍（快排，堆排尤其重要）。</li>
<li>了解一些新兴的技术。</li>
<li>面试之后面试官都会问你有没有什么问题，千万不要没问题，也别傻乎乎的问一些敏感问题。</li>
<li>了解你要面试的公司的产品及竞争产品。</li>
</ol>
<h2 id="Help-Links"><a href="#Help-Links" class="headerlink" title="Help Links"></a>Help Links</h2><ol>
<li><a href="https://segmentfault.com/a/1190000013550405" target="_blank" rel="noopener">一个两年Java的面试总结</a></li>
</ol>
<ol>
<li>Declarations and Access Control</li>
</ol>
<p>1.1 Declare Classes &amp; Interfaces:<br>Class — A template that describes the kinds of state and behavior that objects of its type support.<br>Object — At runtime, when the Java virtual Machine encounters the new keyword, it will use the appropriate class to make an object which is an instance of that class. That object will have its own state, and access to all of the behaviors defined by its class.<br>State (instance variables) — Each object will have its own unique set of instance variables as defined in the class. Collectively, the value assigned to an object’s instance variables make up the object’s state.<br>Behavior (methods) — </p>
<p>1.2 identifiers and keywords<br>Identifiers must start with a letter, a currency character ($), or a connecting character such as the underscore (_). Identifiers cannot start with a number!</p>
<p>Some keywords:<br>strictfp, transient, const, volatile</p>
<p>1.3 Inheritance<br>Inheritance allows code defined in one class to be reused in other classes.<br>In Java, I can define a general, more abstract superclass, and then extend it with more specific subclasses by using the keyword “extend”.<br>The superclass knows nothing of the classes that inherit from it, but all of the subclasses that inherit from the superclass must explicitly declare the inheritance relationship.<br>A subclass that inherits from a superclass is automatically given accessible instance variables and methods defined by the superclass, but is also free to override superclass methods to define more specific behavior.</p>
<p>1.4 Interfaces<br>Interfaces are like a 100-percent abstract superclass that defines the methods a subclass must support, but not how they must be supported.</p>
<p>Interfaces can be implemented by any class, from any inheritance tree. This lets you take radically different classes and give them a common characteristic. Typing in the public and abstract modifiers on the methods is redundant, though, since all interface methods are implicitly public and abstract.</p>
<p>The public modifier is required if you want the interface to have public rather then default access.</p>
<p>Interface can have only abstract methods.<br>All interface methods are implicitly public and abstract.<br>All variables defined in an interface must be public, static, and final — in other words, interfaces can declare only constants, not instance variables.<br>Interface methods must not be static.<br>Interface methods cannot be marked final, strictfp or native.<br>An interface can extend one or more other interfaces. It cannot extend anything else.<br>An interface cannot implement another interface or class.<br>An interface must be declared with the keyword interface.<br>Interface types can be used polymorphically </p>
<p>All interface constants must be declared public, static and final, and by default, they are.</p>
<p>1.5 Class Declarations and Modifiers<br>Access modifiers: public, protected, private, default(package access)<br>Non-access modifiers (including strictfp, final, and abstract)</p>
<p>Although all four access controls work for most method and variable declarations, a class can be declared with only public or default access.</p>
<p>1.6 Class Access<br>When we say code from class A has access to class B, it means class A can do one of three things:<br>Create an instance of class B<br>Extend class B ( in other words, become a subclass of class B)<br>Access certain methods and variables within class B, depending on the access control of those methods and variables.<br>Default Access: or package-level access. A class with default access can be seen only by classes within the same package.<br>Public Access: A class declaration with the public keyword gives all classes from all packages access to the public class.</p>
<p>You can modify a class declaration using the keyword final, abstract, or strictfp.</p>
<p>Final Class: when used in a class declaration, the final keyword means the class can’t be subclassed. e.g. The String class cannot be subclassed. </p>
<p>Abstract Class: An abstract class can never be instantiated, it is only for being extended. If the method end in a semicolon, then both the method and the class must be marked abstract. But you can put non abstract methods in an abstract class.</p>
<p>Polymorphism gives you the greatest degree of flexibility and extensibility.</p>
<p>1.7 Two access issues:<br>Whether method code in one class can access a member of another class<br>Whether a subclass can inherit a member of its superclass (example, by using this.superClassMethod())</p>
<p>Three ways to access a method:<br>Invoking a method declared in the same class<br>Invoking a method using a reference of the class<br>Invoking an inherited method</p>
<p>Public Members:<br>When a method or variable member is declared public, it means all other classes can access the member.</p>
<p>Private Members:<br>Members marked private can’t be accessed by code in any class other than the class in which the private member was declared.<br>When a member is declared private, a subclass can’t inherit it.</p>
<p>Protected and Default Members:<br>The protected and default access control levels are almost identical, but with one critical difference.</p>
<p>A default member may be accessed only if the class accessing the member belongs to the same package,<br>A protected member can be accessed (through inheritance) by a subclass even if the subclass is in a different package.</p>
<p>Default and protected behavior differ only when we talk about subclasses. If the protected keyword is used to define a member, any subclass of the class declaring the member can access it through inheritance. </p>
<p>For a subclass outside the package, the protected member can be accessed only through inheritance.</p>
<p>Local Variables and Access Modifiers<br>Access modifiers cannot be applied to local variables. e.g. private int x = 7. Only final can be applied to local variables.</p>
<p>Nonaccess Member Modifiers<br>Modifiers applied to methods<br>modifiers applied to instance variables.</p>
<p>Final:<br>Final Methods: the final keyword prevents a method from being overridden in a subclass, and is often used to enforce the API functionality of a method.</p>
<p>Abstract:<br>Abstract Methods: An abstract method is a method that’s been declared (as abstract) but not implemented.<br>The abstract method ends with a semicolon instead of curly braces.<br>It is illegal to have even a single abstract method in a class that is not explicitly declared abstract!<br>Any class that extends an abstract class must implement all abstract methods of the superclass, unless the subclass is also abstract.</p>
<p>Transient:<br>If you make an instance variable as transient, you’re telling the JVM to skip this variable when you attempt to serialize the object containing it.</p>
<p>Volatile Variables:<br>The volatile modifier tells the JVM that a thread accessing the variable must always reconcile its own private copy of the variable with the master copy in memory.</p>
<p>Volatile, as with transient, can be applied only to instance variables.</p>
<p>Synchronized:<br>The synchronized keyword indicates that a method can be accessed by only one thread at a time.<br>The synchronized modifier can be applied only to methods — not variables, not classes, just methods.<br>The synchronized modifier can be matched with any of the four access control levels.<br>e.g. public synchronized Record retrieveUserInfo (int id) {}</p>
<p>Native:<br>The native modifier indicates that a method is implemented in platform-dependent code, often in C. It can only be applied to methods - not classes, not variables, just methods. Note that a native method’s body must be semicolon ;</p>
<p>Strictfp:<br>strictfp forces floating points( and any floating-point operations) to adhere to the IEEE 754 standard. With strictfp, you can predict how your floating points will behave regardless of the underlying platform the JVM is running on.</p>
<p>Static:<br>The static modifier is used to create variables and methods that will exist independently of any instances created for the class.<br>All static members exist before you ever make a new instance of a class, and there will be only one copy of a static member regardless of the number of instance of that class.</p>
<p>Things you can mark as static:<br>methods<br>Variables<br>A class nested within another class, but not within a method<br>Initialization blocks</p>
<p>Things you cannot mark as static:<br>Constructors<br>Classes, unless they are nested<br>Interfaces<br>method local inner classes<br>Inner class methods and instance variables<br>Local variables</p>
<p>Variable Declarations:<br>Primitives:<br>8 types: char, boolean, byte, short, int, long, double, float.<br>Once declared, its primitive type can never change, although in most cases its value can change.<br>All six number types(except char and boolean) in Java are made up of a certain number of 8-bit bytes, and are signed. The leftmost bit (the most significant digit) is used to represent the sign, where a 1 means negative and 0 means positive).</p>
<p>Reference variables:<br>A reference variable is used to refer to ( or access) an object.<br>A reference variable can be used to refer to any object of the declared type, or of a subtype of the declared type ( a compatible type).</p>
<p>Declaring Reference Variables<br>Reference variables can be declared as static variables, instance variables, method parameters, or local variables.</p>
<p>Instance variables are defined inside the class, but outside of any method, and are only initialized when the class is instantiated.</p>
<p>Local (Automatic/Stack/Method) Variables:</p>
<p>Local variables are variables declared within a method.<br>It is not just initialized within the method, but also declared within the method.<br>Its life start inside the method, and is destroyed when the method has completed.<br>The local variable is on the stack, if the variable is an object reference, the object itself will still be created on the heap.<br>Before a local variable can be used, it must be initialized with a value.<br>A local variable can’t be referenced in any code outside the method in which it’s declared.</p>
<p>Array Declarations:<br>How to make an array reference variable (declare)<br>How to make an array object (construct)<br>How to populate the array with elements (initialize)</p>
<p>Final Variables:<br>Primitive: the value cannot be altered<br>Reference variable: cannot be reassigned to refer to a different object</p>
<p>Final modifier can be applied to classes, methods, and variables. And examples.</p>
<p>Declaring Enums:</p>
<p>Enums can be declared as their own separate class, or as a class member, however they must not be declared within a method.<br>An enum that isn’t  enclosed in a class can be declared with only the public or default modifier, just like a non-inner class.<br>Declaring Constructors, Methods, and Variables in an enum.</p>
<p>E.g. enum CoffeeSize {BIG, HUGE, OVERWHELMING};<br>CoffeeSize cs = CoffeeSize.BIG;</p>
<p>Switch’s expression:<br>A switch’s expression  must evaluate to a char, byte, short, int or as Java 6, an enum.</p>
<p>the CASE constant must be a compile time constant. E.g. a constant or final variable that is assigned a literal value. </p>
<p>so final int a = 1; is OK.  Final int b; b=2 ; is not OK.</p>
<p>The power of boxing<br>Once a case constant is matched, the JVM will execute the associated code block, and ALL subsequent code blocks (barring a break statement) too.</p>
<p>fall-through logic</p>
<p>The default case can be located at the end, middle or top.</p>
<p>Evaluating the iteration expression and then evaluating the conditional expression are always the last two things that happened in a FOR loop.</p>
<p>Causes of Early Loop Termination:<br>Break, return, and System.exit()</p>
<p>Enhanced For Loop in Java 6</p>
<p>String:</p>
<p>subtle differences between the various methods of creating a String.<br>String s = “abc”. // creates one String object and one reference variable, so “abc” will gain the pool and s will refer to it.<br>String s = new String(“abc”) // creates two objects, and one reference variable. Because we used the new keyword, java will create a new String object in normal (non pool) memory, and s will refer to it. In addition, the literal “abc” will be placed in the pool.</p>
<p>Important methods:</p>
<p>public char charAt(int index)<br>public String concat(String s)<br>public boolean equalsIgnoreCase(String s)<br>public int length()<br>public String replace(char old, char new)<br>public String substring(int begin)<br>public String substring(int begin, int end)<br>public String toLowerCase()<br>public String toString()</p>
<p>e.g. String x = “big surprise”;<br>System.out.println (x.toString());</p>
<p>StringBuilder is not thread safe, Java 5<br>StringBuffer is thread safe but slow</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/03/14/learning-redis/" class="prev">PREV</a><a href="/2018/02/24/google-distributed-database/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://www.yuliang.xyz">Liang Yu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>