<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS 中的 SEL 类型， IMP类型 和 Class类型 · Liang Yu's Website</title><meta name="description" content="iOS 中的 SEL 类型， IMP类型 和 Class类型 - Liang Yu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.yuliang.xyz/atom.xml" title="Liang Yu's Website"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS 中的 SEL 类型， IMP类型 和 Class类型</h1><div class="post-info">Jun 18, 2018</div><div class="post-content"><h1 id="Objective-C-中的消息调用"><a href="#Objective-C-中的消息调用" class="headerlink" title="Objective-C 中的消息调用"></a>Objective-C 中的消息调用</h1><hr>
<p>Ｃ++中的方法调用可能是动态的，也可能是静态的；而ObjC中的消息都为动态的。<br>要讲清楚什么是动态的，以及编译器再这背后都做了什么事情，<br>需要先了解三个概念Class， SEL， IMP</p>
<p>在objc/objc.h中的定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">typedef struct objc_object &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125; *id;</span><br><span class="line"></span><br><span class="line">typedef struct objc_selector *SEL;</span><br><span class="line">typedef id(*IMP) (id, SEL, ...);</span><br></pre></td></tr></table></figure></p>
<h2 id="Class-的含义"><a href="#Class-的含义" class="headerlink" title="Class 的含义"></a>Class 的含义</h2><p>Class 被定义为一个指向 objc_class的结构体指针，这个结构体表示每一个类的类结构。<br>而 objc_class 在objc/objc_class.h 中定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    struct objc_class * isa;</span><br><span class="line">    struct objc_class * super_class;  /*父类*/</span><br><span class="line">    const char *name;                 /*类名字*/</span><br><span class="line">    long version;                   /*版本信息*/</span><br><span class="line">    long info;                        /*类信息*/</span><br><span class="line">    long instance_size;               /*实例大小*/</span><br><span class="line">    struct objc_ivar_list *ivars;     /*实例参数链表*/</span><br><span class="line">    struct objc_method_list **methodLists;  /*方法链表*/</span><br><span class="line">    struct objc_cache *cache;               /*方法缓存*/</span><br><span class="line">    struct objc_protocol_list *protocols;   /*协议链表*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/aff083ec3203" target="_blank" rel="noopener">SEL, IMP and Class</a><br><a href="https://www.jianshu.com/p/4a09d5ebdc2c" target="_blank" rel="noopener">iOS中的SEl和IMP到底是什么</a></p>
<hr>
<h2 id="SEL-类型"><a href="#SEL-类型" class="headerlink" title="SEL 类型"></a>SEL 类型</h2><p>Objective-C 在编译的时候, 会根据方法的名字(包括参数序列),生成一个用来区分这个方法的唯一的一个 ID, 这个 ID 就是 SEL 类型的。</p>
<p>只要方法的名字(包括参数序列)相同,那么它们的 ID 都是相同的。不管是超类还是子类,不管是有没有超类和子类的关系,只要名字相同, 那么 ID 就是一样的。</p>
<p>类成员方法的指针，但不同于C语言中的函数指针，函数指针直接保存了方法的地址，但SEL只是方法编号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SEL methodID = @selector(func1); // @selector()就是取类方法的编号。</span><br><span class="line">SEL methodID = NSSelectorFromString(@&quot;func1&quot;); //在程序执行的时候,通过方法的名字,获取到方法的 ID (SEL)</span><br><span class="line">NSString *funcName = NSStringFromSelector(methodID); // 通过方法的ID，获取方法的名字</span><br><span class="line"></span><br><span class="line">[self performSelector:methodId withObject:nil]; //编号获取后怎么执行对应方法</span><br></pre></td></tr></table></figure>
<p>得到了SEL 变量之后, 通过下面的调用来给一个对象发送消息：<br>[对象 performSelector:SEL 变量 withObject:参数 1 withObject:参数 2];</p>
<p>可以通过给一个方法传递 SEL 参数,让这个方法动态的执行某一个方法;可以通过配置文件指定需要执行的方法,程序读取配置文件之后把方法的字符串翻译成为SEL变量，然后给相应的对象发送这个消息。</p>
<hr>
<h2 id="IMP-类型"><a href="#IMP-类型" class="headerlink" title="IMP 类型"></a>IMP 类型</h2><h3 id="What-is-IMP"><a href="#What-is-IMP" class="headerlink" title="What is IMP?"></a>What is IMP?</h3><p>一个函数指针,保存了方法的地址.</p>
<p>IMP is a short name for Implementation. 它是objetive-C 方法(method)实现代码块的地址，可像C函数一样直接调用。</p>
<p>通常情况下我们是通过[object method:parameter]或 编译后的objc_msgSend()的方式向对象发送消息，然后Objective-C运行时(Objective-C runtime)寻找匹配此消息的IMP, 然后调用它; 但有些时候我们希望获取到IMP进行直接调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void (*setSkinColor_Func) (id, SEL, NSString*); //定义一个函数指针(传统C语言的处理方式)     </span><br><span class="line">IMP say_Func; //定义一个IMP方式的函数指针(obj-C中推荐的方式) </span><br><span class="line"></span><br><span class="line">// IMP就是实现方法，给一个方法起个名字，实现动态调用，不用再使用[对象 message]的方式。  </span><br><span class="line">// IMP 的定义如下:  </span><br><span class="line"></span><br><span class="line">typedef id (*IMP)(id, SEL, ... );</span><br><span class="line"></span><br><span class="line">IMP methodPoint = [self methodForSelector:methodId]; // IMP怎么获得和使用</span><br><span class="line">methodPoint();</span><br></pre></td></tr></table></figure>
<p>我们取得了函数指针之后, 也就意味着我们取得了执行的时候的这段方法的代码的入口,这样我们就可以像普通的 C 语言函数调用一样使用这个函数指针。当然我们可以把函数指针作为参数 传递到其他的方法, 或者实例变量里面, 从而获得极大的动态性。我们获得了动态性, 但是付出的代价就是编译器不知道我们要执行哪一个方法所以在编译的时候不会替我们找出错误, 我们只 有执行的时候才知道, 我们写的函数指针是否是正确的。</p>
<h3 id="Method-structure-in-Objective-C"><a href="#Method-structure-in-Objective-C" class="headerlink" title="Method structure in Objective-C"></a>Method structure in Objective-C</h3><p>每个方法有3个属性.</p>
<h3 id="Get-default-IMP-of-current-method"><a href="#Get-default-IMP-of-current-method" class="headerlink" title="Get default IMP of current method"></a>Get default IMP of current method</h3><hr>
<h2 id="SEL-V-S-IMP"><a href="#SEL-V-S-IMP" class="headerlink" title="SEL V.S. IMP"></a>SEL V.S. IMP</h2><p>IMP和SEL关系</p>
<p>每一个继承于NSObject的类都能自动获得runtime的支持。在这样的一个类中，有一个isa指针，指向该类定义的数据结构体,这个结构体是由编译器编译时为类（需继承于NSObject）创建的.在这个结构体中有包括了指向其父类类定义的指针以及 Dispatch table. Dispatch table是一张SEL和IMP的对应表。(<a href="http://blog.csdn.net/fengsh998/article/details/8614486" target="_blank" rel="noopener">http://blog.csdn.net/fengsh998/article/details/8614486</a>)</p>
<p>也就是说方法编号SEL最后还是要通过Dispatch table表寻找到对应的IMP，IMP就是一个函数指针，然后执行这个方法.</p>
<p>为什么不直接获得函数指针，而要从SEL这个编号走一圈再回到函数指针呢？<br>有了SEL这个中间过程，我们可以对一个编号和什么方法映射做些操作，也就是说我们可以一个SEL指向不同的函数指针，这样就可以完成一个方法名在不同时候执行不同的函数体。另外可以将SEL作为参数传递给不同的类执行。也就是说我们某些业务我们只知道方法名但需要根据不同的情况让不同类执行的时候，SEL可以帮助我们。</p>
<hr>
<h2 id="Class-类型"><a href="#Class-类型" class="headerlink" title="Class 类型"></a>Class 类型</h2><p>类在 Objective-C 也为我们准备了类似的机制, Class 类型。当一个类被正确的编译过后,在这个编译成功的类里面,存在一个变量用于保存这 个类的信息。我们可以通过一个普通的字符串取得 这个 Class,也可以通过我们生成的对象取 得这个 Class。Class 被成功取得之后,我们可以把这个 Class 当作一个已经定义好的类来使用 它。这样的机制允许我们在程序执行的过程当中,可以 Class 来得到对象的类,也可以在程序 执行的阶段动态的生成一个在编译阶段无法确定的一个对象。</p>
<p>因为 Class 里面保存了一个类的所有信息,当然,我们也可以取得一个类的超类。关于 Class 类型,具体的使用格式如下:</p>
<p>Class 变量名 = [类或者对象 class];<br>Class 变量名 = [类或者对象 superclass];<br>Class 变量名 = NSClassFromString(方法名字的字符串);4<br>NSString *变量名 = NSStringFromClass(Class 参数);</p>
<p>第一行代码,是通过向一个类或者对象发送 class 消息来获得这个类或者对象的 Class 变量。<br>第二行代码,是通过向一个类或者对象发送 superclass 消息来获得这个类或者对象的超类的</p>
<p>Class 变量。</p>
<p>第三行代码,是通过调用 NSClassFromString 函数,并且把一个字符串作为参数来取得 Class 变量。这个在我们使用配置文件决定执行的时候的类的时候,NSClassFromString 给我们带来 了极大的方便。</p>
<p>第四行代码,是 NSClassFromString 的反向函数 NSStringFromClass,通过一个 Class 类 型作为变量取得一个类的名字。</p>
<p>当我们在程序里面通过使用上面的第一,二或者第三行代码成功的取得一个 Class 类型的变量, 比如说我们把这个变量名字命名为 myClass,那么我们在以后的代码种可以把 myClass 当作 一个我们已经定义好的类来使用,当然我们可以把这个变量作为参数传递到其他的方法当中让其 他的方法动态的生成我们需要的对象。</p>
<p>当一个类被正确的编译过后,在这个编译成功的类里面,存在一个变量用于保存这 个类的信息。我们可以通过一个普通的字符串取得 这个 Class,也可以通过我们生成的对象取 得这个 Class。因为 Class 里面保存了一个类的所有信息,当然,我们也可以取得一个类的超类。关于 Class 类型,具体的使用格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class 变量名 = [类或者对象 class]; //第一行代码,是通过向一个类或者对象发送 class 消息来获得这个类或者对象的 Class 变量。</span><br><span class="line">Class 变量名 = [类或者对象 superclass]; // 第二行代码,是通过向一个类或者对象发送 superclass 的 Class 变量。</span><br><span class="line"></span><br><span class="line">Class 变量名 = NSClassFromString(方法名字的字符串); // 第三行代码,是通过调用 NSClassFromString 函数,并且把一个字符串作为参数来取得 Class 变量。这个在我们使用配置文件决定执行的时候的类的时候,NSClassFromString 给我们带来 了极大的方便。</span><br><span class="line">NSString *变量名 = NSStringFromClass(Class 参数); // 第四行代码,是 NSClassFromString 的反向函数 NSStringFromClass,通过一个 Class 类 型作为变量取得一个类的名字。</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2018/06/18/ios-runloop/" class="prev">PREV</a><a href="/2018/06/15/web-service-101/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://www.yuliang.xyz">Liang Yu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>