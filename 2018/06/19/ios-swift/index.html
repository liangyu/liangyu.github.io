<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS Swift · Liang Yu's Website</title><meta name="description" content="iOS Swift - Liang Yu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.yuliang.xyz/atom.xml" title="Liang Yu's Website"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS Swift</h1><div class="post-info">Jun 19, 2018</div><div class="post-content"><p>简单，安全，快</p>
<p>Ojbective-C 的方法名字太长</p>
<p>Swift 舍弃了null 而使用Optional 语言</p>
<h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><ul>
<li><p>使用var声明变量，使用let声明常量<br>let str = “String”<br>var str = “String”</p>
</li>
<li><p>类型推断： Swift是强类型的语言<br>let str: String = “String”</p>
</li>
</ul>
<p>其中String就是变量的类型。上面的:String 之所以可以省略是因为后面给变量str赋值了一个String类型的常量。<br>所以编译器能够推断出str也是String类型的。</p>
<h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 (Array)"></a>数组 (Array)</h3><p>在Swift中，Array和Dictionary是值类型的。所以使用简单的等号就可以完成拷贝了。不像有些语言还分深拷贝和浅拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var arrayOfIntegers : [Int] = [1,2,3]</span><br><span class="line">// 隐式指定</span><br><span class="line">var implicitArrayOfIntegers = [1,2,3]</span><br><span class="line"></span><br><span class="line">// 也可以创建空数组,但必须提供其类型</span><br><span class="line">let anotherArray = [Int]()</span><br><span class="line"></span><br><span class="line">let arr = [2.0, 4.5, 3.7] // 数组常量的使用只需要用中括号里面加数组的元素；</span><br><span class="line"></span><br><span class="line">let arrExplicit: [Double] // 显式的声明一个数组变量，则变量的类型为中括号，里面是每个元素的类型；</span><br><span class="line"></span><br><span class="line">// for循环的条件不需要用括号括起来</span><br><span class="line">// 0..&lt;3 表示0到3的一个数组，但不包括3</span><br><span class="line">// 0...3会包括3</span><br><span class="line">for i in 0..&lt;arr.count&#123;</span><br><span class="line">    print(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数组的一些API:</li>
</ul>
<p>arr.append(6.3)<br>arr.remove(at: 3)<br>arr.insert(10.9, at: 1)<br>arr.append(contentsOf: [3.5,6.8])<br>arr[0] = 89.23<br>arr.reversed()<br>arr.sort()</p>
<h3 id="字典-Dictionary"><a href="#字典-Dictionary" class="headerlink" title="字典 (Dictionary)"></a>字典 (Dictionary)</h3><ul>
<li><p>声明与使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var dictionary: [String:Int] = [</span><br><span class="line">    &quot;one&quot; : 1,</span><br><span class="line">    &quot;two&quot; : 2,</span><br><span class="line">    &quot;three&quot; : 3</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值一个空的字典：<br>var emptyDictionary: [Int:Int] = [:]</p>
</li>
</ul>
<ul>
<li><p>字典取值：<br>let value = dictionary[“one”]</p>
</li>
<li><p>字典的添加,更新和删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var emptyDictionary: [Int:Int] = [:]</span><br><span class="line">emptyDictionary[1] = 12</span><br><span class="line">emptyDictionary.updateValue(14, forKey: 1)</span><br><span class="line">emptyDictionary.removeValue(forKey: 1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h3><p>元组就是一种数据结构，里面包含一个或多个值，并且这些值可以是不同类型的。<br>元组中的值可以是命名的也可以是匿名的。如果是命名的，那么可以使用.符号来获取该值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var tuple  = (&quot;name&quot;,12)</span><br><span class="line">var namedTuple = (name:&quot;Name&quot;,age:12)</span><br><span class="line">namedTuple.name = &quot;updateName&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>Tuple 的用处，方法返回多个返回值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func getNameAndAge() -&gt; (String,Int)&#123;</span><br><span class="line">    return (&quot;Ace&quot;,20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举类型（Enum）"><a href="#枚举类型（Enum）" class="headerlink" title="枚举类型（Enum）"></a>枚举类型（Enum）</h3><ul>
<li><p>声明与使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum iOSDeviceType &#123;</span><br><span class="line">    case iPhone</span><br><span class="line">    case iPad</span><br><span class="line">    case iWatch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myDevice = iOSDeviceType.iPhone</span><br></pre></td></tr></table></figure>
</li>
<li><p>当变量的类型已经明确时，赋值可以简化为：<br>var myDevice: iOSDeviceType<br>myDevice = .iPhone </p>
</li>
<li><p>Raw Value<br>每个枚举都可以拥有自己的一个原生类型的raw value，所有的枚举关联的raw value必须<br>是同一个类型的。当类型是Int时，默认按照枚举值的顺序递增其raw value。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction: Int &#123;</span><br><span class="line">    case Up = 1</span><br><span class="line">    case Down // will have the raw value 2</span><br><span class="line">    case Left // will have the raw value 3</span><br><span class="line">    case Right // will have the raw value 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="—-Control-Flow"><a href="#—-Control-Flow" class="headerlink" title="— Control Flow"></a>— Control Flow</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if 1+1 == 2 &#123;</span><br><span class="line">         println(&quot;The math checks out&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var sum = 0</span><br><span class="line">for var i = 0; i &lt; 3; i++ &#123;</span><br><span class="line">    sum += 1 </span><br><span class="line">&#125;</span><br><span class="line">sum // = 3</span><br></pre></td></tr></table></figure>
<h4 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var firstCounter = 0</span><br><span class="line">     for index in 1 ..&lt; 10 &#123;</span><br><span class="line">         firstCounter++</span><br><span class="line">     &#125;</span><br><span class="line">// 循环9次</span><br><span class="line"></span><br><span class="line">var secondCounter = 0</span><br><span class="line">for index in 1 ... 10 &#123; // 注意是三个句点,不是两个</span><br><span class="line">         secondCounter++</span><br><span class="line">     &#125;</span><br><span class="line">// 循环10次</span><br><span class="line"></span><br><span class="line">let loopingArray = [1,2,3,4,5]</span><br><span class="line">var loopSum = 0</span><br><span class="line">for number in loopingArray &#123;</span><br><span class="line">     loopSum += number</span><br><span class="line">&#125;</span><br><span class="line">loopSum // = 15</span><br></pre></td></tr></table></figure>
<h4 id="while-amp-do-while"><a href="#while-amp-do-while" class="headerlink" title="while &amp; do-while"></a>while &amp; do-while</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var countDown = 5</span><br><span class="line"></span><br><span class="line">while countDown &gt; 0 &#123;</span><br><span class="line">     countDown--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countDown</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var countUP = 0</span><br><span class="line">do &#123;</span><br><span class="line">         countUp++</span><br><span class="line">&#125; while countUp &lt; 5</span><br><span class="line">countUp // = 5</span><br></pre></td></tr></table></figure>
<h4 id="if-let"><a href="#if-let" class="headerlink" title="if-let"></a>if-let</h4><p>if-let 语句检查一个可选变量是否包 含值。如果包含,则将这个值指定给一个常量变量,<br>然后运行某段代码。这样可以减少很 多行代码,同时又能够保证安全性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var conditionalString : String? = &quot;a string&quot;</span><br><span class="line">     if let theString = conditionalString? &#123;</span><br><span class="line">         println(&quot;The string is &apos;\(theString)&apos;&quot;)</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         println(&quot;The string is nil&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 输出 &quot;The string is &apos;a string&apos;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> total: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> pro: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// init方法是每个类的构造函数。不需要前缀func。</span></span><br><span class="line">    <span class="keyword">init</span>(total: <span class="type">Double</span>, pro: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.total = total</span><br><span class="line">        <span class="keyword">self</span>.pro = pro</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数的返回值用-&gt; 表示</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doSomeThing</span><span class="params">(param1: String, param2: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// 如何在控制台打印字符以及如何在字符中包含参数（使用反斜杠加括号）</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"do something \(str)"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"over"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>要重写一个函数,要在子类中重新声明它,并添加 override 关键字</p>
<p>class Car: Vehicle {<br>// 继承类可以重写函数<br>             override func description() -&gt; String {<br>                 var description = super.description()<br>                 return description + “, which is a car”<br>} }</p>
<p>在一个被重写的函数中,可以通过 super 回调该函数在父类中的版本</p>
<p>override func description() -&gt; String {<br>         var description = super.description()<br>         return description + “, which is a car”<br>}</p>
<h4 id="初始化与反初始化"><a href="#初始化与反初始化" class="headerlink" title="初始化与反初始化"></a>初始化与反初始化</h4><p>class InitAndDeinitExample {<br>    // 指定的初始化器(也就是主初始化器)<br>    init() {<br>        print(“I’ve been created!”)<br>    }<br>    // 便捷初始化器,是调用上述指定初始化器所必需的<br>    convenience init (text: String) {<br>        self.init() // 这是必需的<br>        print(“I was called with the convenience initializer!”)<br>    }<br>    // 反初始化器<br>    deinit {<br>        print(“I’m going away!”)<br>    }<br>}</p>
<p>var example : InitAndDeinitExample?<br>// 使用指定的初始化器<br>example = InitAndDeinitExample() // 输出”I’ve been created!”<br>example = nil // 输出”I’m going away”<br>// 使用便捷初始化器<br>example = InitAndDeinitExample(text: “Hello”)<br>// 输出”I’ve been created!”<br>// 然后输出”I was called with the convenience initializer”<br>创建一个可以返回 nil 的初始化器(也称为可以失败的初始化器),就在 init 关键字的后面放上一个问号,并在初始化器确定它不能成功地构造该对象时,使用 return nil:</p>
<p>convenience init? (value: Int) {<br>    self.init()<br>    if value &gt; 5 {<br>        // 不能初始化这个对象;返回nil,表示初始化失败 return nil<br>    } }<br>在使用一个可以失败的初始化器时,任何可以在其中存储该结果的变量都是可选的:</p>
<p>let failableExample = InitAndDeinitExample(value: 6)</p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>使用协议的好处是,可以利用 Swift 的类型体系来引用任何遵守某一给定协议的对象，个人现在理解为是Interface概念。</p>
<p>protocol Blinking{<br>    var isBlinking:Bool{get}<br>    var blinkSpeed: Double { get set }<br>    func startBlinking(blinkSpeed: Double) -&gt; Void</p>
<p>}</p>
<p>class Light:Blinking{<br>    var isBlinking = false<br>    var blinkSpeed = 1.2<br>    func startBlinking(blinkSpeed: Double) {<br>            print(“now my speed is (self.blinkSpeed)”)<br>    }</p>
<p>}</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p> extension Int {<br>         var doubled : Int {<br>             return self <em> 2<br>         }<br>         func multiplyWith(anotherNumber: Int) -&gt; Int {<br>             return self </em> anotherNumber<br>} }</p>
<p>2.doubled  // = 4<br>4.multiplyWith(32) // = 128<br>还可以利用扩展使一个类型遵守一个协议</p>
<p>extension Int : Blinking {<br>    var isBlinking : Bool {<br>        return false;<br>    }<br>    var blinkSpeed : Double {<br>        get {<br>            return 0.0; }<br>        set {<br>            // 不做任何事情<br>        } }<br>    func startBlinking(blinkSpeed : Double) {<br>        print(“I am the integer (self). I do not blink.”)<br>    } }<br>2.isBlinking // = false<br>2.startBlinking(2.0) // 输出”I am the integer 2. I do not blink.”</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>单返回值简单函数<br>两个参数一个返回值，都为Int</li>
</ul>
<p>func thirdFunction(firstValue: Int, secondValue: Int) -&gt; Int {<br>         return firstValue + secondValue<br>     }<br>thirdFunction(1, 2)</p>
<ul>
<li>使用元组多返回值<br>func fourthFunction(firstValue: Int, secondValue: Int)<pre><code>-&gt; (doubled: Int, quadrupled: Int) {
return (firstValue * 2, secondValue * 4)
</code></pre>   }<br>fourthFunction(2, 4)</li>
</ul>
<p>// 用数字访问:<br>fourthFunction(2, 4).1 // = 16</p>
<p>// 其他相同,只是使用了名字:<br>fourthFunction(2, 4).quadrupled // = 16</p>
<ul>
<li>外部名称调用<br>在定义函数时,可以为参数指定名字。当无法马上明白每个参数的用途时,这一功能会非 常有用。可以像下面这样来定义参数名字:</li>
</ul>
<p>func addNumbers(firstNumber num1 : Int, toSecondNumber num2: Int) -&gt; Int {<br>         return num1 + num2<br>}<br>addNumbers(firstNumber: 2, toSecondNumber: 3)  // = 5</p>
<p>在为参数创建名字时,就是为参数创建一个内部名字和一个外部名字,一个参数的内部名字应当与外部名字相同。将同一个名字输 入两次也没有什么问题,但的确有一种简便的方式来定义一个外部名字与内部名字相同的 参数——就是在参数名之前放一个 # 符号</p>
<p>func multiplyNumbers(#firstNumber: Int, #multiplier: Int) -&gt; Int {<br>         return firstNumber * multiplier<br>}<br>multiplyNumbers(firstNumber: 2, multiplier: 3)  // = 6</p>
<ul>
<li>将函数用作变量<br>var numbersFunc: (Int, Int) -&gt; Int;<br>// numbersFunc现在可以存储任何接受两个Int并返回一个Int的函数</li>
</ul>
<p>numbersFunc = addNumbers<br>numbersFunc(2, 3) // = 5</p>
<h3 id="closure"><a href="#closure" class="headerlink" title="closure"></a>closure</h3><p>sort需要传递一个闭包作为参数</p>
<p>var numbers = [2,4,34,6,33,1,67,20]<br>var numbersSorted = numbers.sort( { (first, second ) -&gt; Bool in</p>
<pre><code>return first &lt; second
</code></pre><p>})<br>闭包只包含一行代码,可以省略 return 关键字</p>
<p>var numbersSorted = numbers.sort( { $1 &gt; $0})<br>print(numbersSorted)<br>如果一个闭包是函数调用中的最后一个参数,可以将它放在括号外面。这纯粹是为 了提高可读性,不会改变闭包的工作方式</p>
<p>var numbersSorted = numbers.sort(){ $1 &gt; $0}<br>print(numbersSorted)<br>闭包放在变量里面</p>
<p>var comparator = {(a: Int, b: Int) in a &lt; b}<br>comparator(1, 2)  // = true</p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>在将一个方法或属性声明为 public 时,App 中的所有人都能看到它:</p>
<p>// 可供所有人访问<br>public var publicProperty = 123</p>
<p>//如果将一个方法或属性声明为 private,那只能在声明它的源文件内部看到它:<br>// 只能在这个源文件中访问<br>private var privateProperty = 123</p>
<p>// 仅能供本模块访问<br>// 这里的’internal’是默认的,可以省略<br>internal var internalProperty = 123</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>类似C++的运算符重载</p>
<p>class Vector2D {<br>    var x : Float = 0.0<br>    var y : Float = 0.0<br>    init (x : Float, y: Float) {<br>        self.x = x<br>        self.y = y<br>    }</p>
<p>}<br>func +(left : Vector2D, right: Vector2D) -&gt; Vector2D {<br>    let result = Vector2D(x: left.x + right.x, y: left.y + right.y)<br>    return result<br>}</p>
<p>let first = Vector2D(x: 2, y: 2)<br>let second = Vector2D(x: 4, y: 1)<br>let result = first + second</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>Swift与Java泛型相同</p>
<p>class Tree <t> {<br>    // ‘T’现在可以用作一种类型 var value : T<br>    var value:T<br>    var children : [Tree <t>] = []<br>    init(value : T) {<br>        self.value = value<br>    }<br>    func addChild(value : T) -&gt; Tree <t> {<br>        var newChild = Tree<t>(value: value)<br>        children.append(newChild)<br>        reutrn newChild<br>    }<br>}</t></t></t></t></p>
<p>// 整数树<br>let integerTree = Tree<int>(value: 5)<br>// 可以增加包含Int的子树<br>integerTree.addChild(10)<br>//用Swift设计程序 | 45<br>integerTree.addChild(5)<br>// 字符串树<br>let stringTree = Tree<string>(value: “Hello”)<br>stringTree.addChild(“Yes”)<br>stringTree.addChild(“Internets”)</string></int></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>比较字符串</p>
<p>  let string1 : String = “Hello”<br>     let string2 : String = “Hel” + “lo”<br>     if string1 == string2 {<br>         println(“The strings are equal”)<br>  }<br>查找字符串</p>
<p> if string1.hasPrefix(“H”) {<br>         println(“String begins with an H”)<br>     }<br>     if string1.hasSuffix(“llo”) {<br>         println(“String ends in ‘llo’”)<br>     }<br>数据<br>let stringToConvert = “Hello, Swift”<br>let data = stringToConvert.dataUsingEncoding(NSUTF8StringEncoding)</p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><ol>
<li>Returning data from async call in Swift function<br>-&gt; pass callback</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// in Bookshop class</span><br><span class="line">func getGenres( completionHandler: (generes: NSArray) -&gt;()) &#123;</span><br><span class="line">    let task = session.dataTaskWithURL(url) &#123;</span><br><span class="line">    	data, response, error in</span><br><span class="line">    	  ...</span><br><span class="line">    	  resultArray = results</span><br><span class="line">    	  completionHandler(genres: resultArray)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    task.resume()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override func viewDidload() &#123;</span><br><span class="line">	Bookshop.getGenres &#123;</span><br><span class="line">        gernres in </span><br><span class="line">            println(&quot;view controller :\(genres)&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2018/06/19/ios-interview/" class="prev">PREV</a><a href="/2018/06/19/ios-ui-collectionview/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://www.yuliang.xyz">Liang Yu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>