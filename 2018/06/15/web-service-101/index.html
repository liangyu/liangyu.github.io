<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> web-service-101 · Liang Yu's Website</title><meta name="description" content="web-service-101 - Liang Yu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.yuliang.xyz/atom.xml" title="Liang Yu's Website"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">web-service-101</h1><div class="post-info">Jun 15, 2018</div><div class="post-content"><h1 id="什么是-Web-Service？"><a href="#什么是-Web-Service？" class="headerlink" title="什么是 Web Service？"></a>什么是 Web Service？</h1><p>Web Service 是一个软件服务，它提供很多API，指提供给不同设备通过互联网（一般使用 HTTP 协议）进行通信和交换数据的一种服务。</p>
<h3 id="两种架构方式-RESTful-和-SOAP-和-RPC"><a href="#两种架构方式-RESTful-和-SOAP-和-RPC" class="headerlink" title="两种架构方式 RESTful 和 SOAP 和 RPC"></a>两种架构方式 RESTful 和 SOAP 和 RPC</h3><h4 id="RESTful-Representational-state-transfer"><a href="#RESTful-Representational-state-transfer" class="headerlink" title="RESTful: Representational state transfer"></a>RESTful: Representational state transfer</h4><p>面向资源<br>标准: </p>
<ol>
<li>用URI来表示资源， 比如 <a href="http://example.com/user/1" target="_blank" rel="noopener">http://example.com/user/1</a></li>
<li>用标准的HTTP方法 GET POST PUT DELETE 来操作资源， 比如 GET <a href="http://example.com/user/1" target="_blank" rel="noopener">http://example.com/user/1</a></li>
<li>支持资源的多种表现形式，比如在GET 中设置 Content-Type 为 json，让服务端返回json格式的 user 信息</li>
</ol>
<p>RESTful Web Service 并不是协议，它没有规定传输消息的具体格式，它只是一种约定使用 REST 架构实现的 Web Service。RESTful Web Service 相比SOAP Web Service 更加简单和轻量级。现在大部分 RESTful Web Service 都使用类似的形式，例如都使用HTTP传输，使用风格类似的 URL 作为 API 和 使用 JSON 或者 XML 来传输数据等等</p>
<ol>
<li>Client-Server</li>
</ol>
<p>客户端是一个相对独立的实现，它不必考虑数据的持久化存储问题。服务端拥有和保存数据，服务端不去关心客户端内部实现，也不用关心客户端请求的上下文。服务端和客户端之间遵守相同的接口规范</p>
<ol>
<li>Stateless</li>
</ol>
<p>任何时候一个客户端的请求数据都包含能够让服务端完成请求的充分信息，服务端不依赖前后不同请求的顺序和状态信息来完成请求。请求的session信息由客户端持有，并在必要时连同请求数据一起发送。服务端可以使用请求中的session信息去其它外部服务或者数据库获取相关内容进以便对该请求做权限验证等操作。</p>
<p>如果所需数据要通过多次请求才能完成，客户端必须自己负责记录状态（因为服务器不跟踪客户端的状态），在下次请求时附带发出。</p>
<ul>
<li>比如分页</li>
</ul>
<p>一个典型的例子是分页的实现，客户端需要自己保存当前页数，请求下一页时作为参数一起发给服务端，服务端使用该参数返回正确的下一页数据。有些设计，比如Facebook API，服务端返回数据中包含下一页数据的请求URL，客户端只要记录这个URL即可发起下一页的请求。</p>
<ul>
<li>好处：<br>服务端不依赖客户端的请求顺序和状态提高了服务器的可扩展性（scalability）。比如在使用Load balancer的情况下，不能因为某个请求被分配到其它服务器而丢失某些信息从而返回不正确的数据。</li>
</ul>
<p>状态的约定也提高了系统的健壮性（reliability）。如果集群服务器中的其中一台发生故障也不会对系统的平稳运行造成太大影响。</p>
<ul>
<li>缺点：<br>客户端必须每次都要带上相同重复的信息来确定自己的身份和状态，这就造成了传输数据的冗余性。</li>
</ul>
<p>需要权衡</p>
<ol>
<li>Cacheable</li>
</ol>
<p>服务端应该明确规定返回数据的缓存机制，包括是否可缓存，缓存如何失效以及利用缓存获取增量数据而不必每次获取全部数据等。合理的缓存设计可以减少请求次数，进而提高服务器的效率和性能。</p>
<ol>
<li>Layered System</li>
</ol>
<p>客户端不用知道数据是从服务端直接返回还是通过中转代理返回。这样的设计也同样提高了系统的可扩展性。比如可以使用负责均衡和反向代理等技术来对系统进行水平扩展和缓存处理，把系统划分成不同的层次。使用分层设计也方便我们管理不同资源的权限，有利于提高系统的安全性。</p>
<ol>
<li>Code on demand</li>
</ol>
<ol>
<li>Uniform interface</li>
</ol>
<ul>
<li>命名风格一致性</li>
<li><p>数据一次性，多次相同请求 不会产生副作用</p>
</li>
<li><p>一致的数据格式<br>虽然服务端内部不同数据的存储格式可能千差万别，但返回给客户端的数据一定要有一个统一的表现形式。比如 Web Service 请求返回格式要么是 HTML，要么是 XML，要么是 JSON，不能返回服务端自己内部使用的特殊格式</p>
</li>
</ul>
<ul>
<li>可以对已有数据进一步操作（Resource Identifiers）<br>如果客户端拥有一个资源，必要时，客户端应该拥有足有的信息去修改和删除这个资源。通常我们只要在返回的数据中包含一个 UID 即可做到这点。比如从服务端获得了一个订单数据，这个订单数据里应该保证有一个唯一的订单 ID，当我们想对这个订单进行进一步操作时，可以保障操作的是同一个订单。</li>
</ul>
<ul>
<li>数据具有自我描述性<br>每项数据应该是可以自我描述的，方便代码去处理和解析其中的内容。比如通过HTTP返回的数据里面有 [MIME type ]信息，我们从MIME type里面可以知道数据的具体格式，是图片，视频还是JSON。</li>
</ul>
<ul>
<li>应用系统状态变化只依赖超媒体（Hypermedia）<br>应用系统状态变化只依赖于服务端发来的Hypermedia（如超链接 hyperlinks）。举例来说，假设向一个微博 Web Service 请求一条微博信息，服务端响应信息中应该包含和这条微博相关的其它的URL。客户端可以进一步利用这些URL发起请求来获取感兴趣的信息。前面章节中提到的Facebook API 可以从第一页的返回数据中获取下一页的URL也是基于这个设计理念。</li>
</ul>
<h4 id="SOAP：-Simple-Object-Access-Protocol"><a href="#SOAP：-Simple-Object-Access-Protocol" class="headerlink" title="SOAP： Simple Object Access Protocol"></a>SOAP： Simple Object Access Protocol</h4><p>SOAP严格规定了如何发现和描述API，传输的消息也有统一的格式，传输的窄体是XML有严格的格式规范。</p>
<p>使用 SOAP 的 Web Service 实际上是以协议（protocol）的形式工作的。因为 SOAP Web Service 严格规定了如何发现和描述 API，其传输的消息也有严格统一的格式（例如传输的载体XML有严格的格式规范）</p>
<p>消息机制</p>
<h3 id="RPC：-Remote-Procedure-Call"><a href="#RPC：-Remote-Procedure-Call" class="headerlink" title="RPC： Remote Procedure Call"></a>RPC： Remote Procedure Call</h3><p>面向动作</p>
<h1 id="如何构建W-eb-Service-服务，比如雷是Amazon-S3的一个-KV-Storage-Service"><a href="#如何构建W-eb-Service-服务，比如雷是Amazon-S3的一个-KV-Storage-Service" class="headerlink" title="如何构建W eb Service 服务，比如雷是Amazon S3的一个 KV Storage Service"></a>如何构建W eb Service 服务，比如雷是Amazon S3的一个 KV Storage Service</h1><h4 id="KV-Storage-Service"><a href="#KV-Storage-Service" class="headerlink" title="KV Storage Service"></a>KV Storage Service</h4><p>Interface:</p>
<ul>
<li>GET <a href="http://kv.com/key" target="_blank" rel="noopener">http://kv.com/key</a></li>
<li>POST <a href="http://kv.com/key" target="_blank" rel="noopener">http://kv.com/key</a></li>
<li>PUT <a href="http://kv.com/key" target="_blank" rel="noopener">http://kv.com/key</a></li>
<li>DELETE <a href="http://kv.com/key" target="_blank" rel="noopener">http://kv.com/key</a></li>
</ul>
<p>Architecture:</p>
<h3 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h3><p>可以是 HTTP server 帮助处理HTTP 请求，ngnix， apache，也可以用go 或者python直接写一个。 Ngnix是一个无状态的服务，</p>
<h3 id="Storage-Server"><a href="#Storage-Server" class="headerlink" title="Storage Server,"></a>Storage Server,</h3><p>mysql 或者 redis</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul>
<li>DNS 或者 LVS来做</li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>不要忽略http header中的Content-Type<br>URL Rules：</p>
<ol>
<li>Version your API</li>
<li>Use nous, not verbs</li>
<li>GET should always be safe<br>e.g. bad example:<br>GET /api/deleteArticle/id=1</li>
<li>Pagination<br>对于资源集合，分页获取比较合理。<br>范围的集合包含分页有关数据</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "page"     : 1,      // 当前第几页，默认1</span><br><span class="line">    "pages"    : 3,      // 一共多少页</span><br><span class="line">    "per_page" : 10,     // 每页多少数据，最大为per_page_max，如果大于它，则默认为最大值</span><br><span class="line">    "has_next" : true,   // 是否有下一页数据</span><br><span class="line">    "has_prev" : false,  // 是否有前一页数据</span><br><span class="line">    "total"    : 27      // 共有多少页数据</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>URL区分大小写，URL后面加 back forword slash /<br>默认用/结尾，如果GET请求中不带/，则重定向到以/结尾的API上去</li>
</ol>
<p><strong>Request</strong></p>
<p>请求有问题，如果校验数据的时候发现错误，返回状态码400 BAD REQUEST</p>
<ul>
<li><p>Validation：<br>数据类型校验， 比如要求int，给了string<br>数据格式校验， 比如邮箱或者密码，需要满足相应的正则表达式<br>数据逻辑校验， 比如数据包含出生日期和年龄两个字段，如果这两个字段不一match，则数据校验失败</p>
</li>
<li><p>Authentication/Permission<br>API请求需要用户认证时， 如果request中的认证信息不正确，需要返回状态吗401， NOT AUTHORIZED<br>API请求需要验证用户权限时，如果当前用户无相应权限，要返回状态码403，FORBIDDEN</p>
</li>
</ul>
<p>常用的认证机制是：<br>Basic Auth： 很简单<br>OAuth： 企业级</p>
<p>限制机制是对API请求的更近一步限制，只有通过认证的用户符合权限要求，才能访问API<br>分全局型和对象型。全局型就是分组，然后给不同的组不同的权限。</p>
<p><strong>Response</strong><br>GET, PUT, succeed  &lt;– 200 SUCCESS &amp; 返回对应数据<br>GET       Fail     &lt;– 404 NOT FOUND<br>POST      succeed  &lt;– 201 CREATED &amp; 返回创建的数据<br>DELETE    succeed  &lt;– 204 NO CONTENT &amp; 不返回数据</p>
<p><strong>CAP</strong><br>不能同时满足CAP，P必须在 分布式中满足，所以要在C和A中权衡</p>
<ul>
<li>Consistency</li>
<li>Avaliability</li>
<li>Partition tolerance</li>
</ul>
<p>对于一半的NoSQL， 倾向于支持 A &amp; P，对于C，可以允许短时间内数据不一致，但是很快能够达到一致。<br>对于需要强一致的系统，则可以考虑牺牲A来满足 C P，比如很多系统必须写多份才算成功</p>
<h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>数据备份到不同的机器上，采用异步的方法，在一段时间内，不能满足数据一致性，但是最终能够达到一致性。</p>
<p>支持同步的replication，确保数据不能丢失，方法有</p>
<ul>
<li>2PC, 3PC</li>
<li>Paxos, Raft</li>
</ul>
<h3 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h3><p>将一个数据的里面的数据拆分到多个机器</p>
<ol>
<li>hash % num， num是机器数量， 在添加或者删除机器的时候会造成rehash，导致大量的数据迁移</li>
<li>一致性 hash，</li>
<li>路由映射表，外部维护一张路由表，添加删除节点的时候，只需要更改路由表，</li>
</ol>
<p>预分配 + 路由表方式来进行水平扩展，<br>预分配就是将数据切分到 n 个 shard，开始这些shard可以在一个node里面， 随着node增加，只需要迁移相关的shard，同时更新路由表。要求能写出resharding的健壮代码</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>Cache<br><a href="">Facebook - Scaling Memcache at Facebook 简介cache设计</a></li>
<li>消息队列， 当并发量大了以后，光靠同步的API调用无法满足整个系统的性能需求，可以使用 MQ，比如Rabbit MQ</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/06/18/ios-sel-imp-class/" class="prev">PREV</a><a href="/2018/05/21/wright-brother-nm/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://www.yuliang.xyz">Liang Yu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>