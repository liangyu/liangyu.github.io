<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Concurrency in iOS · Liang Yu's Website</title><meta name="description" content="Concurrency in iOS - Liang Yu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.yuliang.xyz/atom.xml" title="Liang Yu's Website"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Concurrency in iOS</h1><div class="post-info">Apr 30, 2017</div><div class="post-content"><h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><h2 id="Principle-of-Fundamental"><a href="#Principle-of-Fundamental" class="headerlink" title="Principle of Fundamental"></a>Principle of Fundamental</h2><ol>
<li><p>Process<br>It is used to refer to a running executable, which can encompass multiple threads.</p>
</li>
<li><p>Thread<br>It is used to refer to a separate path of execution for code.</p>
</li>
<li><p>Task<br>It is used to refer to the abstract concept of work that needs to be performed.</p>
</li>
</ol>
<ul>
<li><p>Critical Section:<br>This is a piece of code that must not be executed concurrently</p>
</li>
<li><p>Race Condition:<br>Race condition can produce unpredictable behavior that aren’t immediately evident through code inspection.</p>
</li>
<li><p>Deadlock:</p>
</li>
<li><p>Thread Safe:</p>
</li>
<li><p>Context Switch:<br>A context switch is the process of storing and restoring execution state when you switch between executing different threads on a single process.</p>
</li>
</ul>
<p><strong>3 and 4 describe when a function completes with respect to another task that the function asks asks GCD to perform. A synchronous function returns only after the completion of a taks that it orders.</strong></p>
<p><strong>An asynchronous function, returns immediately, ordering the task to be done but does not wait for it. Thus, an asynchronous function does not block the current thread of execution from proceeding on to the next function.</strong></p>
<ol>
<li><p>Synchronous</p>
</li>
<li><p>Asynchronous </p>
</li>
</ol>
<ol>
<li>Dispatch Queue<br>A serial dispatch queue runs only one task at a time, waiting until that task is complete before dequeuing and starting a new one.<br>By contrast, a concurrent dispatch queue starts as many tasks as it can without waiting for already started tasks to finish.</li>
</ol>
<p>A serial dispatch queues offer a more efficient alternative to locks and other synchronization primitives.</p>
<p>Tasks must be encapsulated inside either a function of a block object. Blocks can also be moved out of their original scope and copied<br>onto the heap, which is what happens when you submit them to a dispatch queue. </p>
<p><strong>6 and 7 describe when tasks are executed with respect to each other.</strong></p>
<ol>
<li><p>Concurrent<br>Tasks executed concurrently might be executed at the same time</p>
</li>
<li><p>Serial<br>Tasks executed serially are always executed one at a time</p>
</li>
</ol>
<ol>
<li><p>Concurrency<br>via context switch on a same core. </p>
</li>
<li><p>Parallelism<br>at different cores</p>
</li>
</ol>
<p><strong>Parallelism requires concurrency, but concurrency does not guarantee parallelism</strong></p>
<h2 id="Comparison-of-Four-Mulithreading-Mechanism-in-iOS"><a href="#Comparison-of-Four-Mulithreading-Mechanism-in-iOS" class="headerlink" title="Comparison of Four Mulithreading Mechanism in iOS"></a>Comparison of Four Mulithreading Mechanism in iOS</h2><ol>
<li>NSThread </li>
</ol>
<ul>
<li>Advantage: NSThread lightweight， simple</li>
<li>Drawback: manually manage all thread activities, lifecyle, synchronous and sleep</li>
</ul>
<ol>
<li>NSOperation</li>
</ol>
<ul>
<li>Advantage: 自带线程周期管理</li>
<li>Drawback: 面向对象的抽象类，只是实现，或者使用预先定义好的两个子类<br>NSInvocationOperation/ NSBlockOperation</li>
</ul>
<ol>
<li>GCD</li>
</ol>
<ul>
<li>Advantage: most efficient</li>
<li>Drawback: implemented based on c</li>
</ul>
<ol>
<li>summary</li>
</ol>
<ul>
<li>简单安全的话，选择NSOpration</li>
<li>处理大量并发数据，又追求性能效率的， 选择GCD</li>
</ul>
<h2 id="Scenarios"><a href="#Scenarios" class="headerlink" title="Scenarios"></a>Scenarios</h2><ol>
<li>Asynchronously load picuture</li>
</ol>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><h4 id="NSTread"><a href="#NSTread" class="headerlink" title="NSTread"></a>NSTread</h4><h4 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h4><ul>
<li>Operation Queues shows you how to encapsulate and perform tasks using Ojbective-C objects.</li>
</ul>
<h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><ul>
<li>Dispatch Queues shows you how to execute tasks concurrently in C-based objects.</li>
<li>Thread pool management</li>
</ul>
<h5 id="Types-of-the-dispatch-queue"><a href="#Types-of-the-dispatch-queue" class="headerlink" title="Types of the dispatch queue"></a>Types of the dispatch queue</h5><ol>
<li><p>UI <strong>main queue</strong><br>dispatch_get_main_queue()</p>
</li>
<li><p>并行队列 <strong>global dispathc queue</strong></p>
<ol>
<li>priority: HIGH,<br>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)</li>
<li>priority: DEFAULT<br>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</li>
<li>priority: LOW<br>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0)</li>
</ol>
</li>
<li><p>串行队列 <strong>serial queue</strong><br>dispatch_queue_create(“some string”, NULL);</p>
</li>
</ol>
<h5 id="Serial-Queue"><a href="#Serial-Queue" class="headerlink" title="Serial Queue"></a>Serial Queue</h5><h4 id="Concurrent-Queue"><a href="#Concurrent-Queue" class="headerlink" title="Concurrent Queue"></a>Concurrent Queue</h4><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><ul>
<li>进程是一个正在执行的程序实例</li>
<li>进程作为线程的容器，如果某个线程因为I/O操作阻塞，可以去执行其他线程从而最大化利用进程时间片</li>
<li>进程有独立受保护的内存空间，用来保存程序，正文和数据以及其打开的文件，子线程，即将发生的报警，信号/处理程序，全局变量，账户信息。</li>
<li>线程只拥有程序计数器，寄存器，堆栈，状态但与其他线程共享该进程的整个内存空间</li>
<li>线程切换比进程块10到100倍 </li>
</ul>
<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><h1 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h1><h1 id="多线程应用实例"><a href="#多线程应用实例" class="headerlink" title="多线程应用实例"></a>多线程应用实例</h1><p>线程的状态：</p>
<pre><code>exit 或方法执行完毕
</code></pre><p>new  ——&gt; ready  &lt;——-&gt; run ——————–&gt; dead</p>
<p>start 把当前线程放入可调度的线程池里面，</p>
<p>run  – sleep -&gt; blocked  –wake from sleep-&gt; ready</p>
<h1 id="PThreads介绍"><a href="#PThreads介绍" class="headerlink" title="PThreads介绍"></a>PThreads介绍</h1><h1 id="NSThread接口说明"><a href="#NSThread接口说明" class="headerlink" title="NSThread接口说明"></a>NSThread接口说明</h1><h1 id="GCD的概念"><a href="#GCD的概念" class="headerlink" title="GCD的概念"></a>GCD的概念</h1><p>GCD, short for Grand Central Dispath, is used to replace the C based API by Apple. It thinks the concurrency from task and queue, instead of thread and thread functions.</p>
<p>GCD uses queue to dispatch task (block). Queues are serial and concurrency. And Dispatch can be synchronzied or asynchronized.</p>
<p>三种队列类型：<br>Serial Queue: 串行队列将任务1⃣以FIFO的顺序来执行，可以用来做访问某些特定资源的同步处理。<br>Concurrent Queue（Global Queue）: 并发队列能同时执行多个任务，但是这些任务依然是按照FIFO的顺序开始的。<br>Main dispatch queue</p>
<p>GCD有5个不同的队列：</p>
<ol>
<li>运行在主线程中的 main queue</li>
<li>3个不同优先级 (high, default, low) 的后台队列</li>
<li>以及一个优先级更低的后台队列（background priority queue)</li>
</ol>
<p>GCD中两个核心概念：</p>
<ol>
<li>任务：执行什么操作</li>
<li>队列：用来存放任务</li>
</ol>
<p>Serial &amp; Concurrent task<br>Synchronous &amp; Asynchronous function<br>Concurrency &amp; Parallelism<br>Context Switch<br>Dispatch Queues – GCD dispatch queue 是一个对象</p>
<h3 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h3><p>把任务函数block追加到Dispatch Queue中， block的内容便是想执行的任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(queue, ^ &#123;</span><br><span class="line">    // block</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Dispatch Queue 有两种，分为Serial Dispatch Queue ： 在拿下一个任务的时候，上一个任务必须是已经执行完毕的。<br>和 Concurrent Dispatch Queue： 不需要等上一个任务执行完毕。</p>
<ul>
<li><p>系统管理线程，不需要编写线程代码，只需要定义想要执行的任务，然后添加到适当的调度队列，dispatch queue 中。GCD负责创建线程和调度任务，系统直接提供线程管理。GCD在后端管理了一个线程池。GCD决定了你的代码块在哪个线程中执行。</p>
</li>
<li><p>GCD会自动将队列中的任务取出，放到对应的线程中执行。任务的取出按照队列的FIFO原则。</p>
</li>
</ul>
<p>同步：阻塞当前线程，必须要等到同步线程中的任务执行完，返回以后，才能继续执行下一个任务。<br>异步：不会阻塞当前线程，会开启新的线程而不需要等待当前线程的任务执行完毕。</p>
<ol>
<li><p>同步 （不开启新线程），串行队列<br>Serial Dispatch Queue把任务一个一个拿出来，线程一个一个的执行拿出来的任务。</p>
</li>
<li><p>同步，并发队列 （无意义组合）<br>Concurrent Dispatch Queue把任务快速拿出来，但是线程只有一个，所以还是得一个一个执行任务，<br>没有多线程处理。</p>
</li>
<li><p>异步 （开启新线程），串行队列 （按任务进入队列的先后顺序）<br>Serial Dispatch Queue 会把任务一个一个拿出来，但是拿出来的前提是，前一个任务已经执行完毕。<br>虽然有多线程，但是任务是一个一个拿出来执行的，很浪费线程的资源。</p>
</li>
<li><p><strong>异步，并发队列</strong><br>Concurrent Dispatch Queue把任务快速的拿出来，多个线程快速执行，实现多线程操作，提高效率。</p>
</li>
</ol>
<p>方便理解：<br>Dispatch Queue相当于领导， 线程相当于工人， 领导可以串行发布任务，也可以并发发布任务。<br>工人有一人（同步）或者多人（异步）</p>
<p>主队列的异步请求/同步请求，是不是主队列有设么区别？</p>
<p>例子：主队列 + 同步请求 产生死锁的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// DeadLock situation</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">    NSLog(@&quot;#1 ----- before dispatch_sync_call&quot;);</span><br><span class="line">    </span><br><span class="line">    // block 后放入主队列，等待testDeadLock运行结束后在执行，</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;#2 ---- something inside func handled by dispatch queue&quot;);</span><br><span class="line">              &#125;);</span><br><span class="line">    // 但是主线程也在等待同步执行的 block执行完毕，所以#2 #3 出现了死锁</span><br><span class="line">    NSLog(@&quot;#3 ----- after dispatch_sync_call&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="NSOperation接口说明"><a href="#NSOperation接口说明" class="headerlink" title="NSOperation接口说明"></a>NSOperation接口说明</h1><p>问：你愿意用什么多线程方法？我觉得NSOperation好？你解释一下为什么？</p>
<p>Coca Operations：是基于oc实现的，NSOperation以面向对象的方式封装了需要执行的操作。不必关系线程管理，同步的问题。<br>NSOperaion是一个抽象基类，iOS提供了两种默认实现。</p>
<ul>
<li>NSInvocation Operation</li>
<li>NSBlock Operation</li>
</ul>
<p>When called, an asynchronous function does some work behind the scenes to start a task running but returns before that task might actually be complete. Typically, this work involves acquiring a background thread, starting the desired task on that thread, and then sending a notification to the caller (usually through a callback function) when the task is done.</p>
<h2 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h2><p>问题1: 子线程后台运行中拿到了图片，但是UI线程在主线程里。怎么样把现实图片的步骤放入主线程中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self.performSelectorOnMainThread: @selector(showImage)</span><br><span class="line">	withObject: image waitUntilDone: YES]</span><br></pre></td></tr></table></figure></p>
<p>showImage 是方法</p>
<p><strong>扩展</strong><br>Lock<br>NSThread 加锁<br>@synchronized(token) {<br>    statement; // 互斥锁 mutex<br>}</p>
<h3 id="细节-amp-技巧"><a href="#细节-amp-技巧" class="headerlink" title="细节&amp;技巧"></a>细节&amp;技巧</h3><p>在后台线程结束以后，回到主线程刷新界面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[self performSelectorOnMainThread: @selector(refreshTableView)</span><br><span class="line">	 withObject: nil</span><br><span class="line">	 waitUntilDone: YES]</span><br><span class="line"></span><br><span class="line">- (void)refreshTableView &#123;</span><br><span class="line">	[self.tableView reloadData]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把 refreshTableView 方法中的 reloadData 直接放到线程的函数中则会crash</p>
<h6 id="Stand-on-the-Giant’shoulder"><a href="#Stand-on-the-Giant’shoulder" class="headerlink" title="Stand on the Giant’shoulder"></a>Stand on the Giant’shoulder</h6><ol>
<li><a href="http://xuyafei.cn/post/draft/ios-thread" target="_blank" rel="noopener">iOS中的多线程技术-xuyafei</a></li>
<li><a href="">Grand Central Dispatch In-Depth: Part 1/2 by Derek Selander, April 9, 2014</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2017/08/08/design-pattern-delegate/" class="prev">PREV</a><a href="/2017/03/28/her-boston-t/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://www.yuliang.xyz">Liang Yu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>